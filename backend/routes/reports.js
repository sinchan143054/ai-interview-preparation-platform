const express = require('express');
const PDFDocument = require('pdfkit');
const { createObjectCsvWriter } = require('csv-writer');
const fs = require('fs');
const path = require('path');
const Interview = require('../models/Interview');
const Score = require('../models/Score');
const { authMiddleware } = require('../middleware/auth');

const router = express.Router();

router.use(authMiddleware);

// Generate PDF report
router.get('/pdf/:interviewId', async (req, res) => {
  try {
    const { interviewId } = req.params;
    const userId = req.user.userId;

    const interview = await Interview.findOne({ _id: interviewId, userId });
    if (!interview) {
      return res.status(404).json({ message: 'Interview not found' });
    }

    const score = await Score.findOne({ interviewId });

    // Create PDF
    const doc = new PDFDocument({ margin: 50 });

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=interview-report-${interviewId}.pdf`);

    doc.pipe(res);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('Interview Performance Report', { align: 'center' });
    doc.moveDown();

    // Interview Details
    doc.fontSize(12).font('Helvetica');
    doc.text(`Date: ${new Date(interview.completedAt).toLocaleDateString()}`);
    doc.text(`Domain: ${interview.domain}`);
    doc.text(`Difficulty: ${interview.difficulty}`);
    doc.text(`Duration: ${interview.duration} minutes`);
    doc.moveDown();

    // Scores Section
    doc.fontSize(18).font('Helvetica-Bold').text('Score Breakdown');
    doc.moveDown(0.5);

    doc.fontSize(12).font('Helvetica');
    doc.text(`Overall Score: ${interview.finalScore.overall}/100`);
    doc.text(`Technical Knowledge: ${interview.finalScore.technical}/25`);
    doc.text(`Communication: ${interview.finalScore.communication}/25`);
    doc.text(`Confidence: ${interview.finalScore.confidence}/25`);
    doc.text(`Problem Solving: ${interview.finalScore.problemSolving}/25`);
    doc.moveDown();

    // Strengths
    if (score && score.strengths.length > 0) {
      doc.fontSize(16).font('Helvetica-Bold').text('Strengths');
      doc.moveDown(0.5);
      doc.fontSize(12).font('Helvetica');
      score.strengths.forEach((strength) => {
        doc.text(`• ${strength}`);
      });
      doc.moveDown();
    }

    // Weaknesses
    if (score && score.weaknesses.length > 0) {
      doc.fontSize(16).font('Helvetica-Bold').text('Areas for Improvement');
      doc.moveDown(0.5);
      doc.fontSize(12).font('Helvetica');
      score.weaknesses.forEach((weakness) => {
        doc.text(`• ${weakness}`);
      });
      doc.moveDown();
    }

    // Recommendations
    if (score && score.recommendations.length > 0) {
      doc.fontSize(16).font('Helvetica-Bold').text('Recommendations');
      doc.moveDown(0.5);
      doc.fontSize(12).font('Helvetica');
      score.recommendations.forEach((rec) => {
        doc.text(`• ${rec}`);
      });
      doc.moveDown();
    }

    // Question-wise breakdown
    doc.addPage();
    doc.fontSize(18).font('Helvetica-Bold').text('Question-wise Performance');
    doc.moveDown();

    interview.questions.forEach((q, index) => {
      doc.fontSize(14).font('Helvetica-Bold').text(`Question ${index + 1}`);
      doc.fontSize(11).font('Helvetica').text(q.question, { width: 500 });
      doc.moveDown(0.5);

      doc.fontSize(11).font('Helvetica-Bold').text('Your Answer:');
      doc.fontSize(10).font('Helvetica').text(q.userAnswer || 'No answer provided', { width: 500 });
      doc.moveDown(0.5);

      doc.fontSize(11).text(`Score: ${q.scores.overall}/100 | Sentiment: ${q.sentiment}`);
      doc.moveDown();

      if (index < interview.questions.length - 1) {
        doc.moveDown();
      }
    });

    // Footer
    doc.fontSize(10).font('Helvetica').text('Generated by AI Interview Platform', { align: 'center' });

    doc.end();
  } catch (error) {
    console.error('PDF generation error:', error);
    res.status(500).json({ message: 'Failed to generate PDF report', error: error.message });
  }
});

// Generate CSV report
router.get('/csv/:interviewId', async (req, res) => {
  try {
    const { interviewId } = req.params;
    const userId = req.user.userId;

    const interview = await Interview.findOne({ _id: interviewId, userId });
    if (!interview) {
      return res.status(404).json({ message: 'Interview not found' });
    }

    const csvData = interview.questions.map((q, index) => ({
      question_number: index + 1,
      question: q.question,
      user_answer: q.userAnswer || 'No answer',
      technical_score: q.scores.technical,
      communication_score: q.scores.communication,
      confidence_score: q.scores.confidence,
      overall_score: q.scores.overall,
      sentiment: q.sentiment,
    }));

    // Add summary row
    csvData.push({
      question_number: 'FINAL',
      question: 'Overall Performance',
      user_answer: '',
      technical_score: interview.finalScore.technical,
      communication_score: interview.finalScore.communication,
      confidence_score: interview.finalScore.confidence,
      overall_score: interview.finalScore.overall,
      sentiment: '',
    });

    const csvContent = [
      'Question Number,Question,User Answer,Technical Score,Communication Score,Confidence Score,Overall Score,Sentiment',
      ...csvData.map((row) =>
        [
          row.question_number,
          `"${row.question.replace(/"/g, '""')}"`,
          `"${row.user_answer.replace(/"/g, '""')}"`,
          row.technical_score,
          row.communication_score,
          row.confidence_score,
          row.overall_score,
          row.sentiment,
        ].join(',')
      ),
    ].join('\n');

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=interview-report-${interviewId}.csv`);
    res.send(csvContent);
  } catch (error) {
    res.status(500).json({ message: 'Failed to generate CSV report', error: error.message });
  }
});

// Get all interviews summary for CSV export
router.get('/csv-all', async (req, res) => {
  try {
    const userId = req.user.userId;

    const interviews = await Interview.find({ userId, status: 'completed' }).sort({ completedAt: -1 });

    const csvData = interviews.map((interview) => ({
      date: new Date(interview.completedAt).toLocaleDateString(),
      domain: interview.domain,
      difficulty: interview.difficulty,
      duration: interview.duration,
      technical: interview.finalScore.technical,
      communication: interview.finalScore.communication,
      confidence: interview.finalScore.confidence,
      problem_solving: interview.finalScore.problemSolving,
      overall: interview.finalScore.overall,
    }));

    const csvContent = [
      'Date,Domain,Difficulty,Duration (mins),Technical,Communication,Confidence,Problem Solving,Overall Score',
      ...csvData.map((row) =>
        [
          row.date,
          row.domain,
          row.difficulty,
          row.duration,
          row.technical,
          row.communication,
          row.confidence,
          row.problem_solving,
          row.overall,
        ].join(',')
      ),
    ].join('\n');

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=all-interviews-summary.csv');
    res.send(csvContent);
  } catch (error) {
    res.status(500).json({ message: 'Failed to generate CSV report', error: error.message });
  }
});

module.exports = router;
